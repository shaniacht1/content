category: Authentication
commonfields:
  id: Gmail
  version: -1
configuration:
- defaultvalue: ""
  display: Email of user with admin capabilities
  name: adminEmail
  required: true
  type: 9
- defaultvalue: ""
  display: Immutable Google Apps Id
  name: gappsID
  required: false
  type: 0
- defaultvalue: ""
  display: Events query (e.g. "from:example@demisto.com")
  name: query
  required: false
  type: 0
- defaultvalue: ""
  display: Events user key (e.g. example@demisto.com)
  name: queryUserKey
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use System Proxy
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
description: Gmail API and user management (This integration replaces the Gmail functionality
  in the GoogleApps API and G Suite integration).
detaileddescription: "This API enables the usage of Google Admin API. In order to
  enable it, you will need to create an account service private key json file and
  copy its content.\nFollow the steps here to create such a private key and authorize
  the API for usage: [https://developers.google.com/admin-sdk/directory/v1/guides/delegation](https://developers.google.com/admin-sdk/directory/v1/guides/delegation)\n\nIt
  is necessary to authorize the next API's for that service account:\n[https://www.googleapis.com/auth/admin.directory.user.readonly](https://www.googleapis.com/auth/admin.directory.user.readonly)\n\nIn
  order to fetch user roles, please authorize this api too: [https://www.googleapis.com/auth/admin.directory.rolemanagement.readonly](https://www.googleapis.com/auth/admin.directory.rolemanagement.readonly)\n\nIn
  order to revoke user roles, please authorize this api too: [https://www.googleapis.com/auth/admin.directory.rolemanagement](https://www.googleapis.com/auth/admin.directory.rolemanagement)\n\nIn
  order to search user mailboxes, please authorize this api too: [https://www.googleapis.com/auth/gmail.readonly](https://www.googleapis.com/auth/gmail.readonly)\n\nIn
  order to delete emails from user mailbox, please authorize this api too: \n[https://mail.google.com](https://mail.google.com),
  \n[https://www.googleapis.com/auth/gmail.modify](https://www.googleapis.com/auth/gmail.modify)\n\nIn
  order to fetch user security tokens, please authorize this api too: [https://www.googleapis.com/auth/admin.directory.user.security](https://www.googleapis.com/auth/admin.directory.user.security)\n\nIn
  order to fetch mobile info, please authorize this api too: [https://www.googleapis.com/auth/admin.directory.device.mobile.readonly](https://www.googleapis.com/auth/admin.directory.device.mobile.readonly)\n\nIn
  order to preform actions on mobile devices, please authorize this api too: [https://www.googleapis.com/auth/admin.directory.device.mobile.action](https://www.googleapis.com/auth/admin.directory.device.mobile.action)\n\nIn
  order to preform actions on chorme devices, please authorize this api too:[https://www.googleapis.com/auth/admin.directory.device.chromeos](https://www.googleapis.com/auth/admin.directory.device.chromeos)\n\nIn
  order to block email addresses, please authorize this api too:\n[https://www.googleapis.com/auth/gmail.settings.basic](https://www.googleapis.com/auth/gmail.settings.basic)\n\nFor
  the email user param, please choose a user with admin permissions and make sure
  that you follow the steps to perform Google Apps Domain-Wide Delegation of Authority.\n\nIn
  order to revoke/fetch user role, you will need the Immutable Google Apps ID param.\nTo
  get an Immutable Google Apps ID (or customerId):\n1. Go to [https://admin.google.com](https://admin.google.com)\n2.
  Security -> Set up single sign-on (SSO)\n\nYou will see there URLs in the format:\n[https://accounts.google.com/o/saml2/idp?idpid=Cxxxxxxxx](https://accounts.google.com/o/saml2/idp?idpid=Cxxxxxxxx)\nCxxxxxxxx
  is your Immutable Google Apps ID (customerId).\n"
display: Gmail
image: data:image/png;base64,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
name: Gmail
script:
  commands:
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    description: Delete a User
    name: gmail-delete-user
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    description: Returns the set of tokens specified user has issued to 3rd party
      applications.
    name: gmail-get-tokens-for-user
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - auto: PREDEFINED
      defaultValue: basic
      description: 'What subset of fields to fetch for this user, Acceptable values
        are: "basic": Do not include any custom fields for the user. (default), "custom":
        Include custom fields from schemas requested in customFieldMask, "full": Include
        all fields associated with this user.'
      name: projection
      predefined:
      - basic
      - custom
      - full
    - auto: PREDEFINED
      defaultValue: admin_view
      description: Whether to fetch the administrator-only or domain-wide public view
        of the user, will use admin_view(Results include both administrator-only and
        domain-public fields for the user) by default, if true will use "domain_public"(Results
        only include fields for the user that are publicly visible to other users
        in the domain)
      name: view-type-public-domain
      predefined:
      - admin_view
      - domain_public
    - description: A comma-separated list of schema names. All fields from these schemas
        are fetched. This should only be set when projection=custom.
      name: custom-field-mask
    description: Fetch info on specific user
    name: gmail-get-user
    outputs:
    - contextPath: Account.Type
      description: Type of account like Google, facebook
      type: string
    - contextPath: Account.ID
      description: Unique Id of current account
      type: string
    - contextPath: Account.UserName
      description: Username of user with current account
      type: string
    - contextPath: Account.DisplayName
      description: Name to display in current account
      type: string
    - contextPath: Account.Gmail.Address
      description: Email assigned with current account
      type: string
    - contextPath: Account.Group
      description: Group associated with current account
      type: string
    - contextPath: Account.Email.Address
      description: Email assigned with current account
      type: string
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    description: Retrieves a list of all roleAssignments.
    name: gmail-get-user-roles
    outputs:
    - contextPath: GoogleApps.Role.RoleAssignmentId
      description: unique id of role assignment
      type: string
    - contextPath: GoogleApps.Role.ScopeType
      description: Scope type of the role
      type: string
    - contextPath: GoogleApps.Role.Kind
      description: Kind of the Role
      type: string
    - contextPath: GoogleApps.Role.OrgUnitId
      description: Organization in which user was assigned
      type: string
    - contextPath: GoogleApps.Role.ID
      description: The inner role id
      type: string
    - contextPath: GoogleApps.Role.AssignedTo
      description: User Id who was assigned to role
      type: string
  - arguments:
    - description: The ID of the message to retrieve
      name: message-id
      required: true
    - description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    description: Gets the all attachments of an Gmail.
    name: gmail-get-attachments
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The ID of the message to retrieve
      name: message-id
      required: true
    - auto: PREDEFINED
      defaultValue: full
      description: 'The format to return the message in. Acceptable values are: "full":
        Returns the full email message data with body content parsed in the payload
        field; the raw field is not used. (default) / "metadata": Returns only email
        message ID, labels, and email headers / "minimal": Returns only email message
        ID and labels; does not return the email headers, body, or payload / "raw":
        Returns the full email message data with body content in the raw field as
        a base64url encoded string; the payload field is not used'
      name: format
      predefined:
      - full
      - metadata
      - minimal
      - raw
    description: Gets the specified message.
    name: gmail-get-mail
    outputs:
    - contextPath: Gmail.ID
      description: Inner Id of mail in gmail
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID
      type: string
    - contextPath: Gmail.Format
      description: MIME type of mail
      type: string
    - contextPath: Gmail.Labels
      description: Labels of specific mail
      type: string
    - contextPath: Gmail.To
      description: Email Address of receiver
      type: string
    - contextPath: Gmail.From
      description: Email Address of sender
      type: string
    - contextPath: Gmail.Cc
      description: Carbon Copying
      type: string
    - contextPath: Gmail.Bcc
      description: Blind Carbon Copy
      type: string
    - contextPath: Gmail.Subject
      description: Subject of specific mail
      type: string
    - contextPath: Gmail.Body
      description: The content of mail
      type: string
    - contextPath: Gmail.Attachments
      description: Attachments ids separated by ','
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of specific mail (list)
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The email Mailbox
      type: string
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: 'Only return messages matching the specified query. Supports the
        same query format as the Gmail search box. For example, "from:someuser@example.com
        rfc822msgid: is:unread" , for syntax see: "https://support.google.com/mail/answer/7190?hl=en"'
      name: query
    - defaultValue: "100"
      description: Maximum number of results to return. Default is 100. Maximum is
        500. Acceptable values are 1 to 500, inclusive.
      name: max-results
    - description: Fields allows partial responses to be retrieved. See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse
        for more information. (comma separated list)
      name: fields
    - description: Only return messages with labels that match all of the specified
        label IDs. (comma separated list)
      name: labels-ids
    - description: Page token to retrieve a specific page of results in the list.
      name: page-token
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'Include messages from SPAM and TRASH in the results. (Default:
        false)'
      name: include-spam-trash
      predefined:
      - "False"
      - "True"
    - description: 'Specify the sender. for example: "john"'
      name: from
    - description: 'Specify the receiver. for example: "john"'
      name: to
    - description: 'Words in the subject line. for example: "alert"'
      name: subject
    - description: 'Attachments with a certain name or file type. for example: "pdf"
        or "report.pdf"'
      name: filename
    - description: 'Messages in any folder, including Spam and Trash. for example:
        shopping'
      name: in
    - description: 'Search for messages sent during a certain time period. for example:
        2018/05/06'
      name: after
    - description: 'Search for messages sent during a certain time period. for example:
        2018/05/09'
      name: before
    - auto: PREDEFINED
      description: Search for messages sent with attachments.
      name: has-attachments
      predefined:
      - "True"
      - "False"
    description: Search for messages in the user's mailbox.
    name: gmail-search
    outputs:
    - contextPath: Gmail.ID
      description: Inner Id of mail in gmail
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID
      type: string
    - contextPath: Gmail.Format
      description: MIME type of mail
      type: string
    - contextPath: Gmail.Labels
      description: Labels of specific mail
      type: string
    - contextPath: Gmail.To
      description: Email Address of receiver
      type: string
    - contextPath: Gmail.From
      description: Email Address of sender
      type: string
    - contextPath: Gmail.Cc
      description: Carbon Copying
      type: string
    - contextPath: Gmail.Bcc
      description: Blind Carbon Copy
      type: string
    - contextPath: Gmail.Subject
      description: Subject of specific mail
      type: string
    - contextPath: Gmail.Body
      description: The content of mail
      type: string
    - contextPath: Gmail.Attachments
      description: Attachments ids separated by ','
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of specific mail (list)
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The email Mailbox
      type: string
  - arguments:
    - description: 'Only return messages matching the specified query. Supports the
        same query format as the Gmail search box. For example, "from:someuser@example.com
        rfc822msgid: is:unread" , for syntax see: "https://support.google.com/mail/answer/7190?hl=en"'
      name: query
    - defaultValue: "100"
      description: Maximum number of results to return. Default is 100. Maximum is
        500. Acceptable values are 1 to 500, inclusive.
      name: max-results
    - description: Fields allows partial responses to be retrieved. See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse
        for more information. (comma separated list)
      name: fields
    - description: Only return messages with labels that match all of the specified
        label IDs. (comma separated list)
      name: labels-ids
    - description: Page token to retrieve a specific page of results in the list.
      name: page-token
    - auto: PREDEFINED
      defaultValue: "False"
      description: 'Include messages from SPAM and TRASH in the results. (Default:
        false)'
      name: include-spam-trash
      predefined:
      - "False"
      - "True"
    - description: 'Specify the sender. for example: "john"'
      name: from
    - description: 'Specify the receiver. for example: "john"'
      name: to
    - description: 'Words in the subject line. for example: "alert"'
      name: subject
    - description: 'Attachments with a certain name or file type. for example: "pdf"
        or "report.pdf"'
      name: filename
    - description: 'Messages in any folder, including Spam and Trash. for example:
        shopping'
      name: in
    - description: 'Search for messages sent during a certain time period. for example:
        2018/05/06'
      name: after
    - description: 'Search for messages sent during a certain time period. for example:
        2018/05/09'
      name: before
    - auto: PREDEFINED
      description: 'Search for messages sent with attachments. '
      name: has-attachments
      predefined:
      - "False"
      - "True"
    description: Search for messages in all mailboxes.
    name: gmail-search-all-mailboxes
    outputs:
    - contextPath: Gmail.ID
      description: Inner Id of mail in gmail
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID
      type: string
    - contextPath: Gmail.Format
      description: MIME type of mail
      type: string
    - contextPath: Gmail.Labels
      description: Labels of specific mail
      type: string
    - contextPath: Gmail.To
      description: Email Address of receiver
      type: string
    - contextPath: Gmail.From
      description: Email Address of sender
      type: string
    - contextPath: Gmail.Cc
      description: Carbon Copying
      type: string
    - contextPath: Gmail.Bcc
      description: Blind Carbon Copy
      type: string
    - contextPath: Gmail.Subject
      description: Subject of specific mail
      type: string
    - contextPath: Gmail.Body
      description: The content of mail
      type: string
    - contextPath: Gmail.Attachments
      description: Attachments ids separated by ','
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of specific mail (list)
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The email Mailbox
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'What subset of fields to fetch for this user, Acceptable values
        are: "basic": Do not include any custom fields for the user. (default), "custom":
        Include custom fields from schemas requested in customFieldMask, "full": Include
        all fields associated with this user.'
      name: projection
      predefined:
      - basic
      - custom
      - full
    - default: true
      description: The domain name. Use this field to get fields from only one domain.
        To return all domains for a customer account, use the customer query parameter
        instead. Either the customer or the domain parameter must be provided.
      name: domain
    - description: The unique ID for the customers Google account, by default will
        use the value in the integration page. In case of a multi-domain account,
        to fetch all groups for a customer, fill this field instead of domain. As
        an account administrator, you can also use the my_customer alias to represent
        your accounts customerId. The customerId is also returned as part of the Users
        resource. Either the customer or the domain parameter must be provided.
      name: customer
    - auto: PREDEFINED
      description: 'Event sets the optional parameter "event": Event on which subscription
        is intended (if subscribing), Possible values: add/delete/makeAdmin/undelete/update'
      name: event
      predefined:
      - add
      - delete
      - makeAdmin
      - undelete
      - update
    - description: Maximum number of results to return. Default is 100. Maximum is
        500. Acceptable values are 1 to 500, inclusive.
      name: max-results
    - description: A comma-separated list of schema names. All fields from these schemas
        are fetched. This should only be set when projection=custom.
      name: custom-field-mask
    - description: Query string search. Should be of the form "". Complete documentation
        is at https://developers.google.com/admin-sdk/directory/v1/guides/search-users
      name: query
    - auto: PREDEFINED
      description: If set to true, retrieves the list of deleted users. Default is
        false.
      name: show-deleted
      predefined:
      - "False"
      - "True"
    - auto: PREDEFINED
      description: 'Whether to return results in ascending or descending order. possible
        values : ASCENDING/DESCENDING'
      name: sort-order
      predefined:
      - ASCENDING
      - DESCENDING
    - description: Token to authorize and authenticate the action
      name: token
    - auto: PREDEFINED
      description: Whether to fetch the administrator-only or domain-wide public view
        of the user, will use admin_view(Results include both administrator-only and
        domain-public fields for the user) by default, if true will use "domain_public"(Results
        only include fields for the user that are publicly visible to other users
        in the domain)
      name: view-type-public-domain
      predefined:
      - admin_view
      - domain_public
    description: Retrieves a paginated list of either deleted users or all users in
      a domain
    name: gmail-list-users
    outputs:
    - contextPath: Account.Type
      description: Type of account like Google, facebook
      type: string
    - contextPath: Account.ID
      description: Unique Id of current account
      type: string
    - contextPath: Account.UserName
      description: Username of user with current account
      type: string
    - contextPath: Account.DisplayName
      description: Name to display in current account
      type: string
    - contextPath: Account.Gmail.Address
      description: Email assigned with current account
      type: string
    - contextPath: Account.Group
      description: Group associated with current accout
      type: string
  - arguments:
    - description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
    - description: Immutable ID of the role assignment.
      name: role-assignment-id
      required: true
    description: Deletes a role assignment.
    name: gmail-revoke-user-role
  - arguments:
    - default: true
      description: The user's primary email address. The primaryEmail must be unique
        and cannot be an alias of another user.
      name: email
      required: true
    - description: The user's first name.
      name: first-name
      required: true
    - description: The user's last name.
      name: family-name
      required: true
    - description: Stores the password for the user account. A password can contain
        any combination of ASCII characters. A minimum of 8 characters is required.
        The maximum length is 100 characters.
      name: password
      required: true
    description: Creates a user.
    name: gmail-create-user
    outputs:
    - contextPath: Account.Type
      description: Type of account like Google, facebook
      type: string
    - contextPath: Account.ID
      description: Unique Id of current account
      type: string
    - contextPath: Account.UserName
      description: Username of user with current account
      type: string
    - contextPath: Account.DisplayName
      description: Name to display in current account
      type: string
    - contextPath: Account.Gmail.Address
      description: Email assigned with current account
      type: string
    - contextPath: Account.Group
      description: Group associated with current accout
      type: string
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The ID of the message to delete
      name: message-id
      required: true
    - auto: PREDEFINED
      description: Should move to trash (default) or delete permanently
      name: permanent
      predefined:
      - "False"
      - "True"
    description: Delete a mail in the user's mailbox.
    name: gmail-delete-mail
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The ID of the thread to retrieve
      name: thread-id
      required: true
    - auto: PREDEFINED
      defaultValue: full
      description: 'The format to return the message in. Acceptable values are: "full":
        Returns the full email message data with body content parsed in the payload
        field; the raw field is not used. (default) / "metadata": Returns only email
        message ID, labels, and email headers / "minimal": Returns only email message
        ID and labels; does not return the email headers, body, or payload / "raw":
        Returns the full email message data with body content in the raw field as
        a base64url encoded string; the payload field is not used'
      name: format
      predefined:
      - full
      - metadata
      - minimal
      - raw
    description: Gets all messages of a thread
    name: gmail-get-thread
    outputs:
    - contextPath: Gmail.ID
      description: Inner Id of mail in gmail
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID
      type: string
    - contextPath: Gmail.Format
      description: MIME type of mail
      type: string
    - contextPath: Gmail.Labels
      description: Labels of specific mail
      type: string
    - contextPath: Gmail.To
      description: Email Address of receiver
      type: string
    - contextPath: Gmail.From
      description: Email Address of sender
      type: string
    - contextPath: Gmail.Cc
      description: Carbon Copying
      type: string
    - contextPath: Gmail.Bcc
      description: Blind Carbon Copy
      type: string
    - contextPath: Gmail.Subject
      description: Subject of specific mail
      type: string
    - contextPath: Gmail.Body
      description: The content of mail
      type: string
    - contextPath: Gmail.Attachments
      description: Attachments ids separated by ','
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of specific mail (list)
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The email Mailbox
      type: string
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The ID of the message to retrieve
      name: message-id
      required: true
    - description: a comma-seperated list of labels to add to the mail
      isArray: true
      name: add-labels
    - description: a comma-seperated list of labels to remove from the mail
      isArray: true
      name: remove-labels
    description: Move a mail to a different folder
    name: gmail-move-mail
    outputs:
    - contextPath: Gmail.ID
      description: Inner Id of mail in gmail
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID
      type: string
    - contextPath: Gmail.Format
      description: MIME type of mail
      type: string
    - contextPath: Gmail.Labels
      description: Labels of specific mail
      type: string
    - contextPath: Gmail.To
      description: Gmail.Address of receiver
      type: string
    - contextPath: Gmail.From
      description: Gmail.Address of sender
      type: string
    - contextPath: Gmail.Cc
      description: Carbon Copying
      type: string
    - contextPath: Gmail.Bcc
      description: Blind Carbon Copy
      type: string
    - contextPath: Gmail.Subject
      description: Subject of specific mail
      type: string
    - contextPath: Gmail.Body
      description: The content of mail
      type: string
    - contextPath: Gmail.Attachments
      description: Attachments ids separated by ','
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of specific mail (list)
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The Gmail.Mailbox
      type: string
  - arguments:
    - default: true
      description: The source user's email address. The special value me can be used
        to indicate the authenticated user.
      name: src-user-id
      required: true
    - description: The ID of the message to retrieve
      name: message-id
      required: true
    - description: The destination user's email address. The special value me can
        be used to indicate the authenticated user.
      name: dst-user-id
      required: true
    description: Move a mail to a different mailbox
    name: gmail-move-mail-to-mailbox
    outputs:
    - contextPath: Gmail.ID
      description: Inner Id of mail in gmail
      type: string
    - contextPath: Gmail.ThreadId
      description: The thread ID
      type: string
    - contextPath: Gmail.Format
      description: MIME type of mail
      type: string
    - contextPath: Gmail.Labels
      description: Labels of specific mail
      type: string
    - contextPath: Gmail.To
      description: Gmail.Address of receiver
      type: string
    - contextPath: Gmail.From
      description: Gmail.Address of sender
      type: string
    - contextPath: Gmail.Cc
      description: Carbon Copying
      type: string
    - contextPath: Gmail.Bcc
      description: Blind Carbon Copy
      type: string
    - contextPath: Gmail.Subject
      description: Subject of specific mail
      type: string
    - contextPath: Gmail.Body
      description: The content of mail
      type: string
    - contextPath: Gmail.Attachments
      description: Attachments ids separated by ','
      type: unknown
    - contextPath: Gmail.Headers
      description: All headers of specific mail (list)
      type: unknown
    - contextPath: Gmail.Mailbox
      description: The Gmail.Mailbox
      type: string
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: Email address to block messages from.
      name: email-address
      required: true
    description: Add a rule for email deletion by address
    name: gmail-add-delete-filter
  - arguments:
    - default: true
      description: The user's email address. The special value me can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: The sender's display name or email address.
      name: from
    - description: The recipient's display name or email address. Includes recipients
        in the "to", "cc", and "bcc" header fields. You can use simply the local part
        of the email address. For example, "example" and "example@" both match "example@gmail.com".
        This field is case-insensitive.
      name: to
    - description: The mail subject.
      name: subject
    - description: Only return messages matching the specified query. Supports the
        same query format as the Gmail search box. For example, "from:someuser@example.com
        is:unread".
      name: query
    - description: Whether the message has any attachment.
      name: has-attachments
    - description: The size of the entire RFC822 message in bytes, including all headers
        and attachments.
      name: size
    - description: Comma-separated list of labels to add to the message.
      name: add-labels
    - description: Comma-separated list of labels to remove from the message.
      name: remove-labels
    - description: Email address that the message should be forwarded to. the email
        needs to be configured as a forwarding address, see https://support.google.com/mail/answer/10957?hl=en#null.
      name: forward
    - auto: PREDEFINED
      description: How the message size in bytes should be in relation to the size
        field.
      name: size-comparison
      predefined:
      - larger
      - smaller
    description: Add a new filter.
    name: gmail-add-filter
    outputs:
    - contextPath: GmailFilter.ID
      description: Filter ID
      type: string
    - contextPath: GmailFilter.Mailbox
      description: Mailbox containing the filter
      type: string
    - contextPath: GmailFilter.Criteria
      description: Filter Criteria
    - contextPath: GmailFilter.Action
      description: Filter Action
  - arguments:
    - description: User's email address. The special value "me" can be used to indicate
        the authenticated user.
      name: user-id
      required: true
    - description: Limit of result list. default is 100.
      name: limit
    - description: Show only filters associated with address
      name: address
    description: List all filters in a user's mailbox.
    name: gmail-list-filters
    outputs:
    - contextPath: GmailFilter.ID
      description: Filter ID
      type: string
    - contextPath: GmailFilter.Mailbox
      description: Mailbox containing the filter
      type: string
    - contextPath: GmailFilter.Criteria
      description: Filter Criteria
    - contextPath: GmailFilter.Action
      description: Filter Action
  - arguments:
    - description: The user mailbox
      name: user-id
      required: true
    - description: Comma separated list of filter IDs (can be retrieve using `gmail-list-filters`
        command)
      isArray: true
      name: filter_ids
      required: true
    description: Remove a Filter
    name: gmail-remove-filter
  dockerimage: demisto/google-api:1.0
  isfetch: true
  runonce: false
  script: |2-



    ''' IMPORTS '''
    import re
    import json
    import base64
    from datetime import datetime, timedelta
    import httplib2
    import urlparse
    from distutils.util import strtobool
    import sys
    from HTMLParser import HTMLParser, HTMLParseError
    from htmlentitydefs import name2codepoint

    from apiclient import discovery
    from oauth2client import service_account


    ''' GLOBAL VARS '''
    ADMIN_EMAIL = None
    PRIVATE_KEY_CONTENT = None
    GAPPS_ID = None
    SCOPES = ['https://www.googleapis.com/auth/admin.directory.user.readonly']
    PROXY = demisto.params().get('proxy')
    DISABLE_SSL = demisto.params().get('insecure', False)


    ''' HELPER FUNCTIONS '''


    class TextExtractHtmlParser(HTMLParser):
        def __init__(self):
            HTMLParser.__init__(self)
            self._texts = []  # type: list
            self._ignore = False

        def handle_starttag(self, tag, attrs):
            if tag in ('p', 'br') and not self._ignore:
                self._texts.append('\n')
            elif tag in ('script', 'style'):
                self._ignore = True

        def handle_startendtag(self, tag, attrs):
            if tag in ('br', 'tr') and not self._ignore:
                self._texts.append('\n')

        def handle_endtag(self, tag):
            if tag in ('p', 'tr'):
                self._texts.append('\n')
            elif tag in ('script', 'style'):
                self._ignore = False

        def handle_data(self, data):
            if data and not self._ignore:
                stripped = data.strip()
                if stripped:
                    self._texts.append(re.sub(r'\s+', ' ', stripped))

        def handle_entityref(self, name):
            if not self._ignore and name in name2codepoint:
                self._texts.append(unichr(name2codepoint[name]))

        def handle_charref(self, name):
            if not self._ignore:
                if name.startswith('x'):
                    c = unichr(int(name[1:], 16))
                else:
                    c = unichr(int(name))
                self._texts.append(c)

        def get_text(self):
            return "".join(self._texts)


    def html_to_text(html):
        parser = TextExtractHtmlParser()
        try:
            parser.feed(html)
            parser.close()
        except HTMLParseError:
            pass
        return parser.get_text()


    def get_http_client_with_proxy():
        proxies = handle_proxy()
        if not proxies or not proxies['https']:
            raise Exception('https proxy value is empty. Check Demisto server configuration')
        https_proxy = proxies['https']
        if not https_proxy.startswith('https') and not https_proxy.startswith('http'):
            https_proxy = 'https://' + https_proxy
        parsed_proxy = urlparse.urlparse(https_proxy)
        proxy_info = httplib2.ProxyInfo(
            proxy_type=httplib2.socks.PROXY_TYPE_HTTP,  # disable-secrets-detection
            proxy_host=parsed_proxy.hostname,
            proxy_port=parsed_proxy.port,
            proxy_user=parsed_proxy.username,
            proxy_pass=parsed_proxy.password)
        return httplib2.Http(proxy_info=proxy_info, disable_ssl_certificate_validation=DISABLE_SSL)


    def get_credentials(additional_scopes=None, delegated_user=None):
        """Gets valid user credentials from storage.

        If nothing has been stored, or if the stored credentials are invalid,
        the OAuth2 flow is completed to obtain the new credentials.

        Returns:
            Credentials, the obtained credential.
        """
        if not delegated_user or delegated_user == 'me':
            delegated_user = ADMIN_EMAIL
        scopes = SCOPES
        if additional_scopes is not None:
            scopes += additional_scopes

        cred = service_account.ServiceAccountCredentials.from_json_keyfile_dict(json.loads(PRIVATE_KEY_CONTENT),  # type: ignore
                                                                                scopes=scopes)

        return cred.create_delegated(delegated_user)


    def get_service(serviceName, version, additional_scopes=None, delegated_user=None):
        credentials = get_credentials(additional_scopes=additional_scopes, delegated_user=delegated_user)
        if PROXY or DISABLE_SSL:
            http_client = credentials.authorize(get_http_client_with_proxy())
            return discovery.build(serviceName, version, http=http_client)
        return discovery.build(serviceName, version, credentials=credentials)


    def parse_mail_parts(parts):
        body = u''
        html = u''
        attachments = []  # type: list
        for part in parts:
            if 'multipart' in part['mimeType']:
                part_body, part_html, part_attachments = parse_mail_parts(
                    part['parts'])
                body += part_body
                html += part_html
                attachments.extend(part_attachments)
            elif len(part['filename']) == 0:
                text = unicode(base64.urlsafe_b64decode(
                    part['body'].get('data', '').encode('ascii')), 'utf-8')
                if 'text/html' in part['mimeType']:
                    html += text
                else:
                    body += text

            else:
                attachments.append({
                    'ID': part['body']['attachmentId'],
                    'Name': part['filename']
                })

        return body, html, attachments


    def get_email_context(email_data, mailbox):
        context_headers = email_data.get('payload', {}).get('headers', [])
        context_headers = [{'Name': v['name'], 'Value':v['value']}
                           for v in context_headers]
        headers = dict([(h['Name'].lower(), h['Value']) for h in context_headers])
        body = demisto.get(email_data, 'payload.body.data')
        body = body.encode('ascii') if body is not None else ''
        parsed_body = base64.urlsafe_b64decode(body)

        context = {
            'Type': 'Gmail',
            'Mailbox': ADMIN_EMAIL if mailbox == 'me' else mailbox,
            'ID': email_data['id'],
            'ThreadId': email_data['threadId'],
            'Labels': ', '.join(email_data['labelIds']),
            'Headers': context_headers,
            'Attachments': email_data.get('payload', {}).get('filename', ''),
            # only for format 'raw'
            'RawData': email_data.get('raw'),
            # only for format 'full' and 'metadata'
            'Format': headers.get('content-type', '').split(';')[0],
            'Subject': headers.get('subject'),
            'From': headers.get('from'),
            'To': headers.get('to'),
            # only for format 'full'
            'Body': unicode(parsed_body, 'utf-8'),

            # only for incident
            'Cc': headers.get('cc', []),
            'Bcc': headers.get('bcc', []),
            'Date': headers.get('date', ''),
            'Html': None,
        }

        if 'text/html' in context['Format']:  # type: ignore
            context['Html'] = context['Body']
            context['Body'] = html_to_text(context['Body'])

        if 'multipart' in context['Format']:  # type: ignore
            context['Body'], context['Html'], context['Attachments'] = parse_mail_parts(
                email_data.get('payload', {}).get('parts', []))
            context['Attachment Names'] = ', '.join(
                [attachment['Name'] for attachment in context['Attachments']])  # type: ignore

        return context, headers


    TIME_REGEX = re.compile(r'^([\w,\d: ]*) (([+-]{1})(\d{2}):?(\d{2}))?[\s\w\(\)]*$')


    def parse_time(t):
        # there is only one time refernce is the string
        base_time, _, sign, hours, minutes = TIME_REGEX.findall(t)[0]

        if all([sign, hours, minutes]):
            seconds = int(sign + hours) * 3600 + int(sign + minutes) * 60
            parsed_time = datetime.strptime(
                base_time, '%a, %d %b %Y %H:%M:%S') + timedelta(seconds=seconds)
            return parsed_time.isoformat() + 'Z'
        else:
            return datetime.strptime(base_time, '%a, %d %b %Y %H:%M:%S').isoformat() + 'Z'


    def create_incident_labels(parsed_msg, headers):
        labels = [
            {'type': 'Email/ID', 'value': parsed_msg['ID']},
            {'type': 'Email/subject', 'value': parsed_msg['Subject']},
            {'type': 'Email/text', 'value': parsed_msg['Body']},
            {'type': 'Email/from', 'value': parsed_msg['From']},
            {'type': 'Email/html', 'value': parsed_msg['Html']},
        ]
        labels.extend([{'type': 'Email/to', 'value': to}
                       for to in headers.get('To', '').split(',')])
        labels.extend([{'type': 'Email/cc', 'value': cc}
                       for cc in headers.get('Cc', '').split(',')])
        labels.extend([{'type': 'Email/bcc', 'value': bcc}
                       for bcc in headers.get('Bcc', '').split(',')])
        for key, val in headers.items():
            labels.append({'type': 'Email/Header/' + key, 'value': val})

        return labels


    def emails_to_entry(title, raw_emails, format_data, mailbox):
        emails = []
        for email_data in raw_emails:
            context, _ = get_email_context(email_data, mailbox)
            emails.append(context)

        headers = {
            'minimal': ['Mailbox', 'ID', 'Labels', 'Attachment Names', ],
            'raw': ['MailBox', 'ID', 'Labels', 'Attachment Names', 'RawData'],
            'metadata': ['MailBox', 'ID', 'Subject', 'From', 'To', 'Labels', 'Attachment Names', 'Format'],
            'full': ['Mailbox', 'ID', 'Subject', 'From', 'To', 'Labels', 'Attachment Names', 'Format', 'Body'],
        }

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': emails,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, emails, headers[format_data]),
            'EntryContext': {'Gmail(val.ID && val.ID == obj.ID)': emails}
        }


    def mail_to_incident(msg, service, user_key):
        parsed_msg, headers = get_email_context(msg, user_key)

        file_names = []
        command_args = {
            'messageId': parsed_msg['ID'],
            'userId': user_key,
        }

        for attachment in parsed_msg['Attachments']:
            command_args['id'] = attachment['ID']
            result = service.users().messages().attachments().get(**command_args).execute()
            file_data = base64.urlsafe_b64decode(result['data'].encode('ascii'))

            # save the attachment
            file_result = fileResult(attachment['Name'], file_data)

            # check for error
            if file_result['Type'] == entryTypes['error']:
                demisto.error(file_result['Contents'])
                raise Exception(file_result['Contents'])

            file_names.append({
                'path': file_result['FileID'],
                'name': attachment['Name'],
            })

        return {
            'type': 'Gmail',
            'name': parsed_msg['Subject'],
            'details': parsed_msg['Body'],
            'labels': create_incident_labels(parsed_msg, headers),
            'occurred': parse_time(parsed_msg['Date']),
            'attachment': file_names,
            'rawJSON': json.dumps(parsed_msg),
        }


    def users_to_entry(title, response):
        context = []
        for user_data in response:
            context.append({
                'Type': 'Google',
                'ID': user_data.get('id'),
                'UserName': (user_data.get('name').get('givenName')
                             if user_data.get('name') and 'givenName' in user_data.get('name') else None),
                'DisplayName': (user_data.get('name').get('fullName')
                                if user_data.get('name') and 'fullName' in user_data.get('name') else None),
                'Email': {'Address': user_data.get('primaryEmail')},
                'Gmail': {'Address': user_data.get('primaryEmail')},
                'Group': user_data.get('kind'),
                'CustomerId': user_data.get('customerId'),
            })
        headers = ['Type', 'ID', 'UserName',
                   'DisplayName', 'Email', 'Group', 'CustomerId']

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, context, headers),
            'EntryContext': {'Account(val.ID && val.Type && val.ID == obj.ID && val.Type == obj.Type)': context}
        }


    def roles_to_entry(title, response):
        context = []
        for role_data in response:
            context.append({
                'ID': role_data['roleId'],
                'AssignedTo': role_data['assignedTo'],
                'RoleAssignmentId': role_data['roleAssignmentId'],
                'ScopeType': role_data['scopeType'],
                'Kind': role_data['kind'],
                'OrgUnitId': role_data.get('orgUnitId', ''),
            })
        headers = ['ID', 'AssignedTo', 'RoleAssignmentId',
                   'ScopeType', 'Kind', 'OrgUnitId']

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, context, headers),
            'EntryContext': {'Gmail.Role(val.ID && val.ID == obj.ID)': context}
        }


    def tokens_to_entry(title, response):
        context = []
        for token_data in response:
            context.append({
                'DisplayText': token_data.get('displayText'),
                'ClientId': token_data.get('clientId'),
                'Kind': token_data.get('kind'),
                'Scopes': token_data.get('scopes', []),
                'UserKey': token_data.get('userKey'),
            })

        headers = ['DisplayText', 'ClientId', 'Kind', 'Scopes', 'UserKey']

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, context, headers),
            'EntryContext': {'Tokens(val.ClientId && val.ClientId == obj.ClientId)': context}
        }


    def filters_to_entry(title, mailbox, response):
        context = []
        for filter_data in response:
            context.append({
                'ID': filter_data.get('id'),
                'Mailbox': mailbox,
                'Criteria': filter_data.get('criteria'),
                'Action': filter_data.get('action'),
            })

        headers = ['ID', 'Criteria', 'Action', ]

        return {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': context,
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, context, headers),
            'EntryContext': {'GmailFilter(val.ID && val.ID == obj.ID)': context}
        }


    ''' FUNCTIONS '''


    def list_users_command():
        args = demisto.args()
        domain = args.get('domain', ADMIN_EMAIL.split('@')[1])  # type: ignore
        customer = args.get('customer')
        event = args.get('event')
        view_type = args.get('view-type-public-domain', 'admin_view')
        query = args.get('query')
        sort_order = args.get('sort-order')
        max_results = args.get('max-results', 100)
        show_deleted = bool(strtobool(args.get('show-deleted', 'false')))
        projection = args.get('projection', 'basic')
        custom_field_mask = args.get(
            'custom_field_mask') if projection == 'custom' else None

        users = list_users(domain, customer, event, query, sort_order, view_type,
                           show_deleted, max_results, projection, custom_field_mask)
        return users_to_entry('Users:', users)


    def list_users(domain, customer=None, event=None, query=None, sort_order=None, view_type='admin_view',
                   show_deleted=False, max_results=100, projection='basic', custom_field_mask=None):
        command_args = {
            'domain': domain,
            'customer': customer,
            'event': event,
            'viewType': view_type,
            'query': query,
            'sortOrder': sort_order,
            'projection': projection,
            'showDeleted': show_deleted,
            'maxResults': max_results,
        }
        if projection == 'custom':
            command_args['customFieldMask'] = custom_field_mask

        service = get_service('admin', 'directory_v1')
        result = service.users().list(**command_args).execute()

        return result['users']


    def get_user_command():
        args = demisto.args()
        user_key = args.get('user-id')
        view_type = args.get('view-type-public-domain')
        projection = args.get('projection')
        customer_field_mask = args.get('customer-field-mask')

        result = get_user(user_key, view_type, projection, customer_field_mask)
        return users_to_entry('User %s:' % (user_key, ), [result])


    def get_user(user_key, view_type, projection, customer_field_mask=None):
        command_args = {
            'userKey': user_key if user_key != 'me' else ADMIN_EMAIL,
            'projection': projection,
            'viewType': view_type,
        }
        if projection == 'custom':
            command_args['customFieldMask'] = customer_field_mask

        service = get_service('admin', 'directory_v1')
        result = service.users().get(**command_args).execute()

        return result


    def create_user_command():
        args = demisto.args()
        primary_email = args['email']
        first_name = args['first-name']
        family_name = args['family-name']
        password = args.get('password', '')

        if len(password) > 100 or len(password) < 8:
            raise ValueError('password must be over between 8 and 100 characters')

        result = create_user(primary_email, first_name, family_name, password)
        return users_to_entry('New User:', [result])


    def create_user(primary_email, first_name, family_name, password):
        command_args = {
            'primaryEmail': primary_email,
            'name': {
                'givenName': first_name,
                'familyName': family_name,
                'fullName': '%s %s' % (first_name, family_name, ),
            },
            'password': password
        }

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.user'])
        result = service.users().insert(body=command_args).execute()

        return result


    def delete_user_command():
        args = demisto.args()
        user_key = args.get('user-id')

        return delete_user(user_key)


    def delete_user(user_key):
        command_args = {
            'userKey': user_key,
        }

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.user'])
        service.users().delete(**command_args).execute()

        return 'User %s have been deleted.' % (command_args['userKey'], )


    def get_user_role_command():
        args = demisto.args()
        user_key = args['user-id']
        user_key = ADMIN_EMAIL if user_key == 'me' else user_key

        if GAPPS_ID is None:
            raise ValueError('Must provide Immutable GoogleApps Id')

        roles = get_user_role(user_key, GAPPS_ID)
        return roles_to_entry('User Roles of %s:' % (user_key, ), roles)


    def get_user_role(user_key, customer):
        command_args = {
            'customer': customer,
            'maxResults': 100,
        }

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.rolemanagement.readonly',
             'https://www.googleapis.com/auth/admin.directory.rolemanagement'])
        result = service.roleAssignments().list(**command_args).execute()

        user_data = service.users().get(userKey=user_key).execute()

        return [role for role in result['items'] if role['assignedTo'] == user_data['id']]


    def revoke_user_roles_command():
        args = demisto.args()

        user_key = args.get('user-id')
        role_assignment_id = args['role-assignment-id']

        revoke_user_roles(user_key, role_assignment_id)
        return 'Role has been deleted.'


    def revoke_user_roles(user_id, role_assignment_id):
        command_args = {
            'customer': GAPPS_ID,
            'roleAssignmentId': role_assignment_id,
        }

        if GAPPS_ID is None:
            raise ValueError('Must provide Immutable GoogleApps Id')

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.rolemanagement'])
        return service.roleAssignments().delete(**command_args).execute()


    def get_user_tokens_command():
        args = demisto.args()
        user_id = args.get('user-id')
        user_id = ADMIN_EMAIL if user_id == 'me' else user_id

        tokens = get_user_tokens(user_id)

        return tokens_to_entry('Tokens:', tokens)


    def get_user_tokens(user_id):
        command_args = {
            'userKey': user_id,
        }

        service = get_service(
            'admin',
            'directory_v1',
            ['https://www.googleapis.com/auth/admin.directory.user.security'])
        result = service.tokens().list(**command_args).execute()

        return result.get('items', [])


    def search_all_mailboxes():
        command_args = {
            'maxResults': 100,
            'domain': ADMIN_EMAIL.split('@')[1],  # type: ignore
        }

        service = get_service('admin', 'directory_v1')
        result = service.users().list(**command_args).execute()

        entries = [search_command(user['primaryEmail'])
                   for user in result['users']]
        return entries


    def search_command(mailbox=None):
        args = demisto.args()

        user_id = args.get('user-id') if mailbox is None else mailbox
        mailbox = ADMIN_EMAIL if user_id == 'me' else user_id
        subject = args.get('subject', '')
        _from = args.get('from', '')
        to = args.get('to', '')
        before = args.get('before', '')
        after = args.get('after', '')
        filename = args.get('filename', '')
        _in = args.get('in', '')

        query = args.get('query', '')
        fields = args.get('fields')  # TODO
        label_ids = [lbl for lbl in args.get('labels-ids', '').split(',') if lbl != '']
        max_results = int(args.get('max-results', 100))
        page_token = args.get('page-token')
        include_spam_trash = args.get('include-spam-trash', False)
        has_attachments = args.get('has-attachments')
        has_attachments = None if has_attachments is None else bool(
            strtobool(has_attachments))

        if max_results > 500:
            raise ValueError(
                'maxResults must be lower than 500, got %s' % (max_results, ))

        mails, q = search(user_id, subject, _from, to, before, after, filename, _in, query,
                          fields, label_ids, max_results, page_token, include_spam_trash, has_attachments)

        return emails_to_entry('Search in %s:\nquery: "%s"' % (mailbox, q, ), mails, 'full', mailbox)


    def search(user_id, subject='', _from='', to='', before='', after='', filename='', _in='', query='',
               fields=None, label_ids=None, max_results=100, page_token=None, include_spam_trash=False,
               has_attachments=None):
        query_values = {
            'subject': subject,
            'from': _from,
            'to': to,
            'before': before,
            'after': after,
            'filename': filename,
            'in': _in,
            'has': 'attachment' if has_attachments else ''
        }
        q = ' '.join('%s:%s ' % (name, value, )
                     for name, value in query_values.iteritems() if value != '')
        q = ('%s %s' % (q, query, )).strip()

        command_args = {
            'userId': user_id,
            'q': q,
            'maxResults': max_results,
            'fields': fields,
            'labelIds': label_ids,
            'pageToken': page_token,
            'includeSpamTrash': include_spam_trash,
        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            command_args['userId'])
        result = service.users().messages().list(**command_args).execute()

        return [get_mail(user_id, mail['id'], 'full') for mail in result.get('messages', [])], q


    def get_mail_command():
        args = demisto.args()
        user_id = args.get('user-id', ADMIN_EMAIL)
        _id = args.get('message-id')
        _format = args.get('format')

        mail = get_mail(user_id, _id, _format)
        return emails_to_entry('Email:', [mail], _format, user_id)


    def get_mail(user_id, _id, _format):
        command_args = {
            'userId': user_id,
            'id': _id,
            'format': _format,
        }

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            delegated_user=command_args['userId'])
        result = service.users().messages().get(**command_args).execute()

        return result


    def get_attachments_command():
        args = demisto.args()
        user_id = args.get('user-id')
        _id = args.get('message-id')

        attachments = get_attachments(user_id, _id)

        return [fileResult(name, data) for name, data in attachments]


    def get_attachments(user_id, _id):
        mail_args = {
            'userId': user_id,
            'id': _id,
            'format': 'full',
        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            delegated_user=mail_args['userId'])
        result = service.users().messages().get(**mail_args).execute()
        result = get_email_context(result, user_id)[0]

        command_args = {
            'userId': user_id,
            'messageId': _id,
        }
        files = []
        for attachment in result['Attachments']:
            command_args['id'] = attachment['ID']
            result = service.users().messages().attachments().get(**command_args).execute()
            file_data = base64.urlsafe_b64decode(result['data'].encode('ascii'))
            files.append((attachment['Name'], file_data))

        return files


    def move_mail_command():
        args = demisto.args()
        user_id = args.get('user-id')
        _id = args.get('message-id')
        add_labels = [lbl for lbl in args.get('add-labels', '').split(',') if lbl != '']
        remove_labels = [lbl for lbl in args.get(
            'remove-labels', '').split(',') if lbl != '']

        mail = move_mail(user_id, _id, add_labels, remove_labels)
        return emails_to_entry('Email:', [mail], 'full', user_id)


    def move_mail(user_id, _id, add_labels, remove_labels):
        command_args = {
            'userId': user_id,
            'id': _id,
            'body': {
                'addLabelIds': add_labels,
                'removeLabelIds': remove_labels,
            }

        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.modify'],
            delegated_user=user_id)
        result = service.users().messages().modify(**command_args).execute()

        return result


    def move_mail_to_mailbox_command():
        args = demisto.args()
        src_user_id = args.get('src-user-id')
        message_id = args.get('message-id')
        dst_user_id = args.get('dst-user-id')

        new_mail_id = move_mail_to_mailbox(src_user_id, message_id, dst_user_id)

        mail = get_mail(dst_user_id, new_mail_id, 'full')
        return emails_to_entry('Email:', [mail], 'full', dst_user_id)


    def move_mail_to_mailbox(src_mailbox, message_id, dst_mailbox):
        # get the original mail
        mail = get_mail(src_mailbox, message_id, 'raw')

        # import the mail to the destination mailbox
        command_args = {
            'userId': dst_mailbox,
            'body': {
                'raw': mail['raw'],
            }
        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.modify'],
            delegated_user=dst_mailbox)
        result = service.users().messages().import_(**command_args).execute()

        # delete the original mail
        delete_mail(src_mailbox, message_id, True)

        return result['id']


    def delete_mail_command():
        args = demisto.args()

        user_id = args['user-id']
        _id = args['message-id']
        permanent = bool(strtobool(args.get('permanent', 'false')))

        return delete_mail(user_id, _id, permanent)


    def delete_mail(user_id, _id, permanent):
        command_args = {
            'userId': user_id,
            'id': _id,
        }

        service = get_service(
            'gmail',
            'v1',
            ['https://mail.google.com',
             'https://www.googleapis.com/auth/gmail.modify'],
            delegated_user=command_args['userId'])
        if permanent:
            service.users().messages().delete(**command_args).execute()
            return 'Email has been successfully deleted.'
        else:
            service.users().messages().trash(**command_args).execute()
            return 'Email has been successfully moved to trash.'


    def get_thread_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        _id = args.get('thread-id')
        _format = args.get('format')

        messages = get_thread(user_id, _id, _format)

        return emails_to_entry('Emails of Thread:', messages, _format, user_id)


    def get_thread(user_id, _id, _format):
        command_args = {
            'userId': user_id,
            'id': _id,
            'format': _format
        }

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            delegated_user=user_id)
        result = service.users().threads().get(**command_args).execute()

        return result['messages']


    def add_delete_filter_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        user_id = user_id if user_id.lower() != 'me' else ADMIN_EMAIL
        _from = args.get('email-address')

        _filter = add_filter(user_id, _from=_from, add_labels=['TRASH', ])

        return filters_to_entry('New filter:', user_id, [_filter])


    def add_filter_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        user_id = user_id if user_id.lower() != 'me' else ADMIN_EMAIL
        _from = args.get('from')
        to = args.get('to')
        subject = args.get('subject')
        query = args.get('query')
        has_attachments = args.get('has-attachments')
        size = args.get('size')
        size_comparison = args.get('size-comparison')
        forward = args.get('forward')
        add_labels = args.get('add-labels', '').split(',')
        add_labels = add_labels if any(add_labels) else None
        remove_labels = args.get('remove-labels', '').split(',')
        remove_labels = remove_labels if any(remove_labels) else None

        _filter = add_filter(user_id,
                             _from=_from,
                             to=to,
                             subject=subject,
                             query=query,
                             has_attachments=has_attachments,
                             size=size,
                             size_comparison=size_comparison,
                             forward=forward,
                             add_labels=add_labels,
                             remove_labels=remove_labels,
                             )

        return filters_to_entry('New filter:', user_id, [_filter])


    def add_filter(user_id, _from=None, to=None, subject=None, query=None, has_attachments=None, size=None,
                   size_comparison=None, forward=None, add_labels=None, remove_labels=None):
        command_args = {
            'userId': user_id,
            'body': {
                'criteria': {},
                'action': {},
            }
        }

        if _from is not None:
            command_args['body']['criteria']['from'] = _from
        if to is not None:
            command_args['body']['criteria']['to'] = to
        if subject is not None:
            command_args['body']['criteria']['subject'] = subject
        if query is not None:
            command_args['body']['criteria']['query'] = query
        if has_attachments is not None:
            command_args['body']['criteria']['hasAttachment'] = has_attachments
        if size is not None:
            command_args['body']['criteria']['size'] = size
        if size_comparison is not None:
            command_args['body']['criteria']['size_comparison'] = size_comparison
        if add_labels is not None:
            command_args['body']['action']['addLabelIds'] = add_labels
        if remove_labels is not None:
            command_args['body']['action']['removeLabelIds'] = remove_labels
        if forward is not None:
            command_args['body']['action']['forward'] = forward

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.settings.basic'],
            delegated_user=user_id)
        result = service.users().settings().filters().create(**command_args).execute()

        return result


    def list_filters_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        user_id = user_id if user_id.lower() != 'me' else ADMIN_EMAIL
        address = args.get('address')
        limit = int(args.get('limit', 100))

        filters = list_filters(
            user_id,
            address=address,
            limit=limit)

        return filters_to_entry('filters:', user_id, filters)


    def list_filters(user_id, address=None, limit=100):
        command_args = {
            'userId': user_id,
        }
        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.settings.basic'],
            delegated_user=user_id)
        result = service.users().settings().filters().list(**command_args).execute()
        filters = result.get('filter', [])
        if address is not None:
            filters = [f for f in filters if address in {f['criteria'].get('from'), f['criteria'].get('to')}]

        return filters[:limit]


    def remove_filter_command():
        args = demisto.args()

        user_id = args.get('user-id', ADMIN_EMAIL)
        ids = args.get('filter_ids', '')
        if isinstance(ids, STRING_TYPES):  # alternativly it could be an array
            ids = ids.split(',')

        for _id in ids:
            remove_filter(user_id, _id)

        return 'filters were removed successfully.'


    def remove_filter(user_id, _id):
        command_args = {
            'userId': user_id,
            'id': _id
        }

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.settings.basic'],
            delegated_user=user_id)
        result = service.users().settings().filters().delete(**command_args).execute()

        return result


    def fetch_incidents():
        params = demisto.params()
        user_key = params.get('queryUserKey')
        user_key = user_key if user_key else ADMIN_EMAIL
        query = '' if params['query'] is None else params['query']
        last_run = demisto.getLastRun()
        last_fetch = last_run.get('time')

        # handle first time fetch
        if last_fetch is None:
            last_fetch = datetime.now() - timedelta(days=1)
        else:
            last_fetch = datetime.strptime(
                last_fetch, '%Y-%m-%dT%H:%M:%SZ')
        current_fetch = last_fetch

        service = get_service(
            'gmail',
            'v1',
            ['https://www.googleapis.com/auth/gmail.readonly'],
            user_key)

        query += last_fetch.strftime(' after:%Y/%m/%d')
        LOG('GMAIL: fetch parameters:\nuser: %s\nquery=%s\nfetch time: %s' %
            (user_key, query, last_fetch, ))

        result = service.users().messages().list(
            userId=user_key, maxResults=100, q=query).execute()

        incidents = []
        # so far, so good
        LOG('GMAIL: possible new incidents are %s' % (result, ))
        for msg in result.get('messages', []):
            msg_result = service.users().messages().get(
                id=msg['id'], userId=user_key).execute()
            incident = mail_to_incident(msg_result, service, user_key)
            temp_date = datetime.strptime(
                incident['occurred'], '%Y-%m-%dT%H:%M:%SZ')

            # update last run
            if temp_date > last_fetch:
                last_fetch = temp_date + timedelta(seconds=1)

            # avoid duplication due to weak time query
            if temp_date > current_fetch:
                incidents.append(incident)
        demisto.info('extract {} incidents'.format(len(incidents)))
        demisto.setLastRun({'time': last_fetch.isoformat().split('.')[0] + 'Z'})
        return incidents


    def main():
        global ADMIN_EMAIL, PRIVATE_KEY_CONTENT, GAPPS_ID
        ADMIN_EMAIL = demisto.params()['adminEmail'].get('identifier', '')
        PRIVATE_KEY_CONTENT = demisto.params()['adminEmail'].get('password', '{}')
        GAPPS_ID = demisto.params().get('gappsID')
        ''' EXECUTION CODE '''
        COMMANDS = {
            'gmail-list-users': list_users_command,
            'gmail-get-user': get_user_command,
            'gmail-create-user': create_user_command,
            'gmail-delete-user': delete_user_command,
            'gmail-get-user-roles': get_user_role_command,
            'gmail-revoke-user-role': revoke_user_roles_command,
            'gmail-get-tokens-for-user': get_user_tokens_command,
            'gmail-search-all-mailboxes': search_all_mailboxes,
            'gmail-search': search_command,
            'gmail-get-mail': get_mail_command,
            'gmail-get-attachments': get_attachments_command,
            'gmail-move-mail': move_mail_command,
            'gmail-move-mail-to-mailbox': move_mail_to_mailbox_command,
            'gmail-delete-mail': delete_mail_command,
            'gmail-get-thread': get_thread_command,
            'gmail-add-filter': add_filter_command,
            'gmail-add-delete-filter': add_delete_filter_command,
            'gmail-list-filters': list_filters_command,
            'gmail-remove-filter': remove_filter_command,
        }
        command = demisto.command()
        LOG('GMAIL: command is %s' % (command, ))
        try:
            if command == 'test-module':
                list_users(ADMIN_EMAIL.split('@')[1])
                demisto.results('ok')
                sys.exit(0)

            if command == 'fetch-incidents':
                demisto.incidents(fetch_incidents())
                sys.exit(0)

            cmd_func = COMMANDS.get(command)
            if cmd_func is None:
                raise NotImplementedError(
                    'Command "{}" is not implemented.'.format(command))
            else:
                demisto.results(cmd_func())  # type: ignore
        except Exception as e:
            import traceback
            if command == 'fetch-incidents':
                LOG(traceback.format_exc())
                LOG.print_log()
                raise
            else:
                return_error('GMAIL: {}'.format(str(e)), traceback.format_exc())


    # python2 uses __builtin__ python3 uses builtins
    if __name__ == "__builtin__" or __name__ == "builtins":
        main()
  type: python
system: true
